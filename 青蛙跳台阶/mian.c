#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

//  青蛙跳台阶
//一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
//如果n=1，只有一种跳法，那就是1
//如果n=2，那么有两种跳法，2，[1,1]
//如果n=3，那么有三种跳法，[1,1,1],,[1,2],[2,1]
//如果n=4，那么有五种跳法，[1,1,1,1],[1,1,2],[1,2,1],[2,1,1],[2,2]
//如果n=5，那么有八种跳法，[1,1,1,1,1],[1,1,1,2],[1,1,2,1],[1,2,1,1],[2,1,1,1],[2,2,1],[2,1,2],[1,2,2]
//结果为1，2，3，5，8  观察发现其实就是斐波那契数列

// 递归做法 
// 由于斐波那契数列 三组里第一项加第二项=第三项 由此我们求frog(n)=frog(n-1)+frog(n-2)
//int frog(int n)
//{
//	if (n <= 2)
//	{
//		return n;
//	}
//	else
//		return frog(n - 1) + frog(n - 2);
//}

// 非递归做法 直接设定xyz三项 在循环中一直第一第二相加
// int frog(int n)
// {
//     if (n <= 2)
//     {
//         return n;
//     }
//     int x = 1;
//     int y = 2;
//     int z = 0;
//     while (n > 2)
//     {
//         z = x + y;
//         x = y;
//         y = z;
//         n--;
//     }
//     return z;
// }

// 主函数
// int main()
// {
//     int n = 0;
//     scanf("%d", &n);
//     int a=frog(n);
//     printf("%d\n", a);
//     return 0;
// }


// 强化版本 青蛙可以跳上1、2、3、4到n层一次 其跳到终点有多少方法
// f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)= f(0) + f(1) + f(2) + f(3) + ... + f(n-2)+f(n-1)
// f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2)
// 所以我们得到f(n)=2*f(n-1)

// 递归做法
//int frog(int x)
//{
//
//	if (x <= 1)
//		return 1;
//	else
//		return 2 * frog(x - 1);
//
//}

//  非递归做法 因为可以一次跳n阶 因为f(n)=2*f(n-1) 所以设定一个值f也就是最开始跳的一次
//  利用循环来f不停的*2并赋值给自己 直到不满足循环要求
// int frog(int n)  
// {
// 	int f = 1;
// 	if (n == 0 || n <= 1)
// 		return n;
// 		int x = 2;
// 		for (x=2;x<=n;x++)
// 		{
// 			f = 2 * f;
// 		}
// 	return f;
// }
// int main()
// {
// 	int n = 0;
// 	scanf("%d", &n);
// 	frog(n);
// 	printf("%d\n", frog(n));
// 	return 0;
// }

// 主函数
//int main()
//{
//	int i = 0;
//	scanf("%d", &i);
//	frog(i);
//	printf("%d", frog(i));
//}
